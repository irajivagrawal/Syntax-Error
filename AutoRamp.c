#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S2,     irseekLeft,     sensorHiTechnicIRSeeker600)
#pragma config(Sensor, S3,     gyroSensor,     sensorI2CHiTechnicGyro)
#pragma config(Sensor, S4,     irseekRight,    sensorHiTechnicIRSeeker600)
#pragma config(Motor,  mtr_S1_C1_1,     motorLeft,     tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorRight,    tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     motorSpokes,   tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     motorLift,     tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S1_C3_1,    Wrist,                tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    DropRight,            tServoStandard)
#pragma config(Servo,  srvo_S1_C3_4,    DropLeft,             tServoStandard)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#include "drivers/HTIRS2-driver.h"
#include "drivers/HTGYRO-driver.h"

#define BOUND(n, l, h) (((n) < (l)) ? (l) : ((n) > (h)) ? (h) : (n))

#define maxPower 95
#define stepPower 50
#define reducedPower 20

#define front  1
#define back  -1
#define left   1
#define right -1
#define up 1
#define down -1

const int rotCount = 1440;
const bool display = 0;
const float wheelRadius = 2.0;
const float wheelCirc = 2 * 3.14 * wheelRadius;
const float robotRadius = 10;// Horizontal distance between 2 wheels /2.0 = 8.05

void InitializeServos()
{
	 	servoTarget[Wrist] =  200;
	 	servoTarget[DropLeft] =  10;
	 	servoTarget[DropRight] =  235;
}

void ResetChassisEncoders() // Reset all the encoders of the chassis motors
{
  nMotorEncoder[motorLeft] = 0;
  nMotorEncoder[motorRight]= 0;
}

void StopChassisMotors()
{
	motor[motorLeft]   = 0;
	motor[motorRight]  = 0;
}

void TurnAngle(float angle, int dir)
{
	float numRotCount = (rotCount * angle * robotRadius) / (360.0 * wheelRadius);
	int count = ceil(numRotCount);

	if(display)
	{
		nxtDisplayCenteredTextLine(1,"Turn %d",count);
		wait1Msec(1000);
	}

	ResetChassisEncoders();
	while(abs(nMotorEncoder[motorRight]) <= count)
	{
		  motor[motorLeft] = -1 * dir * maxPower;
		  motor[motorRight]= dir * maxPower;
      if( display )
		     nxtDisplayBigStringAt(4, 7, "Left: %d",abs(nMotorEncoder[motorLeft]));
	}

	StopChassisMotors();
	wait1Msec(500);
	ResetChassisEncoders();
}

void TurnWithGyro(float angle, int dir, short power)
{
	float curAngle = SensorValue[gyroSensor];
	float turnAngle = 0.0;
	while (turnAngle < angle)
	{
		motor[motorLeft] = -1 * dir * power;
		motor[motorRight] = dir * power;
		wait1Msec(10);

		turnAngle += abs(SensorValue[gyroSensor] - curAngle) * 0.01;
	}

	motor[motorLeft] = 0.0;
	motor[motorRight] = 0.0;
	wait1Msec(100);
}

void MoveChassis(int power, short dir, float dist)
{

	float numRotCount = 1440 * (dist/wheelCirc);
	int count = ceil(numRotCount);

	if(display)
	{
		if(dir > 0)
			nxtDisplayTextLine(1, "Move Front:");
		else
			nxtDisplayTextLine(1, "Move Back:");
		wait1Msec(500);
	}

	ResetChassisEncoders();
  while(abs(nMotorEncoder[motorRight]) <= count)
  {
		motor[motorLeft] = dir * power;
	  motor[motorRight] = dir * power;
  }

	StopChassisMotors();
	wait1Msec(500);
  ResetChassisEncoders();
}

void LiftArm(int time, int dir, short power) // time in milli seconds
{
	motor[motorLift] = dir * power;
	wait1Msec(time);

	motor[motorLift] = 0;
}

void SetWristPos(short target1, short target2)
{
  	servoTarget[Wrist] =  target1;
  	wait1Msec(50);

  	servoTarget[Wrist] =  target2;
  	wait1Msec(50);
}

void HookOrReleaseGoal(bool hook)
{
	if (hook)// move hooks down
	{
  	servoTarget[DropLeft] =  235;
  	servoTarget[DropRight] =  10;
  	wait1Msec(100);
  }
  else // move hooks up
  {
  	servoTarget[DropLeft] =  10;
  	servoTarget[DropRight] =  235;
  	wait1Msec(100);
  }
}

task main()
{
  	InitializeServos();
  	while (nNxtButtonPressed < 0)
  	{
  	}

//    waitForStart();

    if(nNxtButtonPressed == 1)	// right arrow: 60 cm goal
    {
	  	MoveChassis(50, back, 64.5);	// come down the ramp
	  	MoveChassis(25,back, 15);			// Approach goal slowly
			HookOrReleaseGoal(true);

	  	LiftArm(1250, up, 75);				// Lift Arm to position basket above 60 cm goal

	  	SetWristPos(100, 40);					// Drop Ball in 60cm goal
			wait1Msec(2000);
			SetWristPos(100, 200);				// Bring Basket straight

			LiftArm(800, down, 40);

			TurnWithGyro(45,right, 50);
			MoveChassis(75,front,20);

			TurnWithGyro(40, left, 50);
			MoveChassis(75,front,85);

		  TurnWithGyro(90,right, 50);

			MoveChassis(75,front,10);
		}
		else if(nNxtButtonPressed == 2)	// left arrow: 90 cm goal
		{
	  	MoveChassis(50, back, 64.5);	// come down the ramp
	  	TurnWithGyro(90, left, 50);

	  	MoveChassis(50,back, 15);
	  	TurnWithGyro(90, right, 50);

	  	MoveChassis(50,back, 25);
	  	TurnWithGyro(40, right, 50);

	  	MoveChassis(25,back, 20);			// Approach goal slowly
	  	HookOrReleaseGoal(true);

	  	LiftArm(2400, up, 75);				// Lift Arm to posityion basket above 60 cm goal

	  	SetWristPos(100, 25);					// Drop Ball in 60cm goal
			wait1Msec(2000);
			SetWristPos(100, 200);				// Bring Basket straight

			LiftArm(1400, down, 50);
			MoveChassis(75,front,35);

			TurnWithGyro(35, left, 50);
			MoveChassis(75,front,80);

			TurnWithGyro(75, right, 50);
			MoveChassis(75,front,20);
		}

		InitializeServos();
		wait1Msec(1000);
}

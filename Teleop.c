#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     irseekLeft,     sensorI2CCustom)
#pragma config(Sensor, S3,     lightSensor,    sensorLightActive)
#pragma config(Sensor, S4,     irseekRight,    sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     motorLeft,     tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorRight,    tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     motorSpokes,   tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     motorLift,     tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S1_C3_1,    Wrist,                tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    DropRight,            tServoStandard)
#pragma config(Servo,  srvo_S1_C3_4,    DropLeft,             tServoStandard)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"

#define MAX(a, b) if((a) > (b)) maxValue = a; else maxValue = b;

#define button1   0x01     	//buttonX
#define button2   0x02			//buttonA
#define button3   0x04			//buttonB
#define button4   0x08			//buttonY
#define button5   0x10			//buttonLB
#define button6   0x20			//buttonRB
#define button7   0x40			//buttonLT
#define button8   0x80			//buttonRT
#define button9  0x100			//buttonBack
#define button10 0x200			//buttonStart

#define maxPower 99
#define stepPower 50
#define reducedPower 20

#define front  1
#define back  -1
#define left   1
#define right -1
#define up 1
#define down -1

const int rotCount = 1440;
const bool display = 0;
short motorSteps = 5;
const float wheelRadius = 2.0;
const float robotRadius = 8.05;	// Horizontal distance between 2 wheels /2.0

int spokeIsOn = 0;

void InitializeServos()
{
	 	servoTarget[Wrist] =  200;
	 	servoTarget[DropLeft] =  10;
	 	servoTarget[DropRight] =  235;
}

void ResetChassisEncoders() // Reset all the encoders of the chassis motors
{
  nMotorEncoder[motorLeft] = 0;
  nMotorEncoder[motorRight]= 0;
}

void StopChassisMotors()
{
	motor[motorLeft]   = 0;
	motor[motorRight]  = 0;
}

void TurnChassis(short dir)
{
//	short currentDropPos = ServoValue[DropRight];
	if(display)
	{
		if(dir > 0)
			nxtDisplayTextLine(1, "Left Turn:");
		else
			nxtDisplayTextLine(1, "Right Turn:");
		wait1Msec(500);
	}

	ResetChassisEncoders();
  while(abs(nMotorEncoder[motorRight]) <= 3*45)
  {

		motor[motorLeft] = dir * -1 * stepPower;
	  motor[motorRight] = dir * stepPower;
  }

  StopChassisMotors();
  wait1Msec(200);
  ResetChassisEncoders();
}

void MoveChassis(short dir)
{
//	short currentDropPos = ServoValue[Drop];
	if(display)
	{
		if(dir > 0)
			nxtDisplayTextLine(1, "Move Front:");
		else
			nxtDisplayTextLine(1, "Move Back:");
		wait1Msec(500);
	}

	ResetChassisEncoders();
  while(abs(nMotorEncoder[motorRight]) <= 3*45)
  {

		motor[motorLeft] = dir * stepPower;
	  motor[motorRight] = dir * stepPower;
  }

	StopChassisMotors();
	wait1Msec(200);
  ResetChassisEncoders();
}

void TurnAngle(float angle, int dir)
{
	float numRotCount = (rotCount * angle * robotRadius) / (360.0 * wheelRadius);
	int count = ceil(numRotCount);

	if(display)
	{
		nxtDisplayCenteredTextLine(1,"Turn %d",count);
		wait1Msec(1000);
	}

	ResetChassisEncoders();
	while(abs(nMotorEncoder[motorRight]) <= count)
	{
		  motor[motorLeft] = -1 * dir * maxPower;
		  motor[motorRight]= dir * maxPower;
      if( display )
		     nxtDisplayBigStringAt(4, 7, "Left: %d",abs(nMotorEncoder[motorRight]));
	}

	StopChassisMotors();
	wait1Msec(200);
	ResetChassisEncoders();
}

void MoveRobot()
{
	short currentWristPos = ServoValue[Wrist];
	short currentDropLeftPos=ServoValue[DropLeft];
	short currentDropRightPos= ServoValue[DropRight];

  if (joystick.joy1_Buttons & button5)
  	TurnChassis(left);
  else if (joystick.joy1_Buttons & button6)
		TurnChassis(right);
  else if (joystick.joy1_Buttons & button7)
  	MoveChassis(back);
  else if (joystick.joy1_Buttons & button8)
		MoveChassis(front);
	else if(joystick.joy1_x1 < -15 || joystick.joy1_x1 > 15) // turn right and left
	{
		float scaledValue = (float)joystick.joy1_x1/128.0;
		short power = scaledValue * maxPower;

		motor[motorLeft] = power;
    motor[motorRight] = -1 * power;
  }
  else if(joystick.joy1_y1 < -15 || joystick.joy1_y1 > 15) //move front and back
  {
  	float scaledValue =(float)joystick.joy1_y1/128.0;
		short power = scaledValue * maxPower;

		motor[motorLeft] = power;
		motor[motorRight]= power;
  }
  else if ((joystick.joy1_Buttons & button9) && (joystick.joy1_Buttons & button10))
  	motorSteps = 3;
  else if ((joystick.joy1_Buttons & button9) && motorSteps > 1)
  	motorSteps--;
 	else if ((joystick.joy1_Buttons & button10) && motorSteps < 7)
 		motorSteps++;
 	else if (joystick.joy1_Buttons & button1)
  	TurnAngle(90, left);
 	else if(joystick.joy1_Buttons & button3)
   	TurnAngle(90, right);
  else if (joystick.joy1_Buttons & button2)//Left servo drop
  {
  	if(currentDropLeftPos >= 145)
  		servoTarget[DropLeft] =  10; // moves up
	  else if (currentDropLeftPos < 145)
	  	servoTarget[DropLeft] = 235; //moves down
  }
   else if (joystick.joy1_Buttons & button4)// Right servo drop
   {
    if(currentDropRightPos >= 145)
  		servoTarget[DropRight] =  10; // moves down
	  else if (currentDropRightPos < 145)
	  	servoTarget[DropRight] = 235; //moves up
   }
  else if(joystick.joy1_y2 > 15)
  {
  	float scaledValue =(float)joystick.joy1_y2/128.0;
  	short pos = scaledValue * 20;

  	if(currentDropRightPos <= 225)
  	 servoTarget[DropRight] += pos;

  if(currentDropLeftPos >= 25)
  	servoTarget[DropLeft] -= pos;
  }
  else if(joystick.joy1_y2 < -15)
  {
  	float scaledValue =(float)joystick.joy1_y2/128.0;
  	short pos = scaledValue * 20;

  	if(currentDropRightPos >= 25)
  		servoTarget[DropRight] += pos;

  if(currentDropLeftPos <= 225)
  	servoTarget[DropLeft] -= pos;
  }
  // Joystick2 starts
  else if(joystick.joy2_y1 < -15 || joystick.joy2_y1 > 15)// move arm up/down
  {
  	float scaledValue =(float)joystick.joy2_y1/128.0;
		short power = scaledValue * maxPower;

		motor[motorLift] = power;
  }
  else if(joystick.joy2_x1 < -15 || joystick.joy2_x1 > 15)
	{
		float scaledValue = (float)joystick.joy2_x1/128.0;
		motor[motorLift]= scaledValue * 40;
  }
 	else if (joystick.joy2_Buttons & button7 && currentWristPos <= 245)
 	{
  		servoTarget[Wrist] +=10;
 	}
 	else if (joystick.joy2_Buttons & button5 && currentWristPos >= 15)	//Move Servo UP in steps
  {
  		servoTarget[Wrist] -= 10;
  }
	else if (joystick.joy2_Buttons & button1) //box initial pos
		servoTarget[Wrist] =  200;
  else if  (joystick.joy2_Buttons & button3)
  	servoTarget[Wrist] =  100; // box half way up
  else if (joystick.joy2_Buttons & button4) // spin spokes for collection
  {
  	if(spokeIsOn)
  	{
  		motor[motorSpokes]=0;
  		spokeIsOn = 0;
  	}
  	else
  	{
  		motor[motorSpokes]=95;
  		spokeIsOn = 1;
  	}
  }
  else if (joystick.joy2_Buttons & button2)// spin spokes the other way
  {
  	if(spokeIsOn)
  	{
  		motor[motorSpokes]=0;
  		spokeIsOn = 0;
  	}
  	else
  	{
  		motor[motorSpokes]=-95;
  		spokeIsOn = 1;
  	}
  }
  else if(joystick.joy2_y2 < -15 || joystick.joy2_y2 > 15)
  {
		float scaledValue = (float)joystick.joy2_y2/128.0;
		short power = scaledValue * maxPower / 2.0;

		if(!spokeIsOn)
			motor[motorSpokes] = power;
  }
  else if (joystick.joy2_Buttons & button10)
  	InitializeServos();
  else
 	{
		StopChassisMotors();
		if(!spokeIsOn)
			motor[motorSpokes] = 0;

		motor[motorLift] = 0;

	}
}


task main()
{
	//servoTarget[Drop] =  75;  // controlled by Driver 1

	ResetChassisEncoders();
	InitializeServos();
	waitForStart();   // wait for start of tele-op phase

	while(true)
	{
		getJoystickSettings(joystick);
    wait1Msec(200);

    MoveRobot();

	}
}
